# Логика автосмены статуса проекта по комплектам

## Правила

1. **Нет комплектов** → статус проекта = **«Начальный»**.
2. **Появился хотя бы один комплект** → статус проекта = **«Комплектация»**.

## Где это должно срабатывать

- При **создании комплекта** с привязкой к проекту (`project_id`): если у проекта до этого не было комплектов, после вставки комплекта статус проекта меняется на «Комплектация».
- При **удалении комплекта**: если у него был `project_id` и после удаления у проекта не остаётся комплектов, статус проекта меняется на «Начальный».

## Цепочка вызовов (как было задумано)

### Создание комплекта со страницы проекта

1. Пользователь на **карточке проекта** (projects/view) нажимает «Добавить комплект», заполняет форму и отправляет POST.
2. **projects/view()**: `form_complect.process().accepted` → вызывается `complects_service.create_complect(db, ..., project_id=int(project_id), ...)`.
3. **complects_service.create_complect()**:
   - вставляет запись в `complects` с `project_id`;
   - делает `db.commit()`;
   - считает: `count = db(db.complects.project_id == project_id_int).count()`;
   - если `count == 1`: ищет id статуса «Комплектация» по имени и вызывает `projects_service.update_project_status(db, project_id_int, status_id)`.
4. **projects_service.update_project_status()**: обновляет у проекта `status_id` и `status_started_at`, делает `db.commit()`.
5. Контроллер делает `redirect` на projects/view — при новой загрузке страницы проект должен подтянуться уже с новым статусом.

### Возможные причины, почему «не работает»

- В таблице **project_statuses** нет записей с именами ровно **«Начальный»** и **«Комплектация»** (или опечатка/пробелы) → поиск по имени возвращает `None` → смена статуса не вызывается.
- Поиск по имени в `get_status_by_name` падает или возвращает не то (например, из‑за `.lower()` или кодировки) → `status_complectation_id` остаётся `None` → `update_project_status` не вызывается.
- Исключение внутри `update_project_status` (например, нет прав, ошибка БД) → возвращается `{'success': False}`; в `create_complect` мы не проверяем этот результат и не показываем пользователю ошибку.
- На странице проекта статус берётся из закэшированного или старого объекта `project` до редиректа — маловероятно, т.к. после редиректа данные читаются заново.

## Где реализовано

- **Создание первого комплекта**: в контроллере `controllers/projects.py`, функция `view()`. После успешного `complects_service.create_complect(...)` вызывается подсчёт комплектов проекта; если `count == 1`, ищется статус «Комплектация» по имени (`project_statuses_service.get_status_by_name(db, 'Комплектация')`), при отсутствии используется id=2; затем вызывается `projects_service.update_project_status(db, project_id, status_id)`. При ошибке обновления статуса пользователю показывается сообщение.
- **Удаление последнего комплекта**: в `modules/complects_service.py`, функция `delete_complect()` — после удаления комплекта проверяется, остались ли у проекта комплекты; если нет, статус проекта переводится в «Начальный» (по имени или id=1).
- **Поиск статуса**: в `project_statuses_service.get_status_by_name(db, name)` — по **точному** совпадению поля `name` (без учёта регистра убран для надёжности). В контроллере при отсутствии записи «Комплектация» используется запасной id=2.
